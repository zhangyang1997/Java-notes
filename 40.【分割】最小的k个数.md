# 题目描述
输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是【1,2,3,4,】无顺序要求。
# 方法一 快速分割
基于数组的第k个数字来调整，使得比第k个数字小的所有数字都位于数组的左边，比第k个数字大的所有数字都位于数组的右边。调整之后，位于数组左边的k个数字就是最小的k个数字（这k个数字不一定是排序的）。

时间复杂度O(N)。

```
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        ArrayList<Integer> ret=new ArrayList<>();
        if(k<=0||k>input.length){
            return ret;
        }
        int start=0;
        int end=input.length-1;
        int pIndex=part(input,start,end);//主元下标
        while(pIndex!=k-1){//如果主元下标等于k,结束循环
            if(pIndex<k-1){//如果主元下标小于k
                start=pIndex+1;//对大于k的子序列进行分割
                pIndex=part(input,start,end);//继续返回子序列的主元下标
            }else{//如果主元下标大于k
                end=pIndex-1;//然后对小于k的子序列进行分割
                pIndex=part(input,start,end);//继续返回子序列的主元下标
            }
        }
        for(int i=0;i<k;i++){
            ret.add(input[i]);
        }
        return ret;
    }
    private int part(int[] a,int left,int right){
        int p=a[left];//主元为左指针元素
        while(left<right){//如果左指针等于右指针，结束循环
            while(left<right&&a[right]>=p){//如果右指针指元素大于等于主元
                right--;//右指针左移
            }
            swap(a,left,right);//右指针找到比主元小的元素，交换
            while(left<right&&a[left]<p){//如果左指针元素小于主元
                left++;//左指针右移
            }
            swap(a,left,right);//左指针找到比主元大的元素，交换
        }
        return left;//返回将数组分割为两半的主元下标
    }
    private void swap(int[] a,int i,int j){
        int t=a[i];
        a[i]=a[j];
        a[j]=t;
    }
}
```
