# 题目描述
输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是【1,2,3,4,】无顺序要求。
# 方法一 快速分割
基于数组的第k个数字来调整，使得比第k个数字小的所有数字都位于数组的左边，比第k个数字大的所有数字都位于数组的右边。调整之后，位于数组左边的k个数字就是最小的k个数字（这k个数字不一定是排序的）。

时间复杂度O(N)。

```
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        ArrayList<Integer> ret=new ArrayList<>();
        if(k<=0||k>input.length){
            return ret;
        }
        int start=0;
        int end=input.length-1;
        int pIndex=part(input,start,end);//返回排序后的主元下标
        while(pIndex!=k-1){//如果主元下标等于k,结束循环
            if(pIndex<k-1){//如果主元下标小于k
                start=pIndex+1;//数组开始位置为主元后
                pIndex=part(input,start,end);//继续返回子数组的主元下标
            }else{//如果主元下标大于k
                end=pIndex-1;//数组结束位置在主元前
                pIndex=part(input,start,end);//继续返回子数组的主元下标
            }
        }
        for(int i=0;i<k;i++){
            ret.add(input[i]);
        }
        return ret;
    }
    private int part(int[] a,int start,int end){
        int p=a[start];//主元为左指针元素
        while(start<end){//如果左指针等于右指针，结束循环
            while(start<end&&a[end]>p){//如果右指针指元素大于主元
                end--;//右指针左移
            }
            swap(a,start,end);//否则左右元素交换
            while(start<end&&a[start]<=p){//如果左指针元素小于等于主元
                start++;//左指针右移
            }
            swap(a,start,end);//否则左右元素交换
        }
        return start;//返回数组的主元位置下标，将数组分割为两份
    }
    private void swap(int[] a,int i,int j){
        int t=a[i];
        a[i]=a[j];
        a[j]=t;
    }
}
```
